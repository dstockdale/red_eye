<script>
  import {
    Chart,
    CandlestickSeries,
    TimeScale,
  } from "svelte-lightweight-charts";
  import Dexie from "dexie";
  import { db } from "../db";

  let timeScale;
  let candleSeries;

  const period = {
    timeFrom: { day: 1, month: 1, year: 2018 },
    timeTo: { day: 1, month: 1, year: 2019 },
  };
  export let data;
  // let data = generateBarsData(period);

  let timer = null;

  function handleVisibleLogicalRangeChange() {
    if (!timeScale || !candleSeries) {
      return;
    }
    if (timer !== null) {
      return;
    }
    const logicalRange = timeScale.getVisibleLogicalRange();
    const barsInfo = candleSeries.barsInLogicalRange(logicalRange);

    // timer = setTimeout(() => {
    //   const logicalRange = timeScale.getVisibleLogicalRange();
    //   if (logicalRange !== null) {
    //     const barsInfo = candleSeries.barsInLogicalRange(logicalRange);
    //     if (barsInfo !== null && barsInfo.barsBefore < 10) {
    //       const firstTime = getBusinessDayBeforeCurrentAt(data[0].time, 1);
    //       const lastTime = getBusinessDayBeforeCurrentAt(
    //         firstTime,
    //         Math.max(100, -barsInfo.barsBefore + 100)
    //       );
    //       const newPeriod = {
    //         timeFrom: lastTime,
    //         timeTo: firstTime,
    //       };
    //       data = [...generateBarsData(newPeriod), ...data];
    //     }
    //   }
    //   timer = null;
    // }, 500);

    console.log(logicalRange);
    console.log(barsInfo);
  }

  function handleTimeScaleRef(api) {
    timeScale = api;
  }
  function handleSeriesRef(api) {
    candleSeries = api;
  }

  function getBusinessDayBeforeCurrentAt(date, daysDelta) {
    const dateWithDelta = new Date(
      Date.UTC(date.year, date.month - 1, date.day - daysDelta, 0, 0, 0, 0)
    );
    return {
      year: dateWithDelta.getFullYear(),
      month: dateWithDelta.getMonth() + 1,
      day: dateWithDelta.getDate(),
    };
  }

  function generateBarsData(period) {
    const res = [];
    const controlPoints = generateControlPoints(res, period);
    for (let i = 0; i < controlPoints.length - 1; i++) {
      const left = controlPoints[i];
      const right = controlPoints[i + 1];
      fillBarsSegment(left, right, res);
    }
    return res;
  }

  function fillBarsSegment(left, right, points) {
    const deltaY = right.price - left.price;
    const deltaX = right.index - left.index;
    const angle = deltaY / deltaX;
    for (let i = left.index; i <= right.index; i++) {
      const basePrice = left.price + (i - left.index) * angle;
      const openNoise = 0.1 - Math.random() * 0.2 + 1;
      const closeNoise = 0.1 - Math.random() * 0.2 + 1;
      const open = basePrice * openNoise;
      const close = basePrice * closeNoise;
      const high = Math.max(basePrice * (1 + Math.random() * 0.2), open, close);
      const low = Math.min(basePrice * (1 - Math.random() * 0.2), open, close);
      points[i].open = open;
      points[i].high = high;
      points[i].low = low;
      points[i].close = close;
    }
  }

  function generateControlPoints(res, period, dataMultiplier) {
    let time =
      period !== undefined ? period.timeFrom : { day: 1, month: 1, year: 2018 };
    const timeTo =
      period !== undefined ? period.timeTo : { day: 1, month: 1, year: 2019 };
    const days = getDiffDays(time, timeTo);
    dataMultiplier = dataMultiplier || 1;
    const controlPoints = [];
    controlPoints.push({ index: 0, price: getRandomPrice() * dataMultiplier });
    for (let i = 0; i < days; i++) {
      if (i > 0 && i < days - 1 && Math.random() < 0.05) {
        controlPoints.push({
          index: i,
          price: getRandomPrice() * dataMultiplier,
        });
      }
      res.push({ time: time });
      time = nextBusinessDay(time);
    }
    controlPoints.push({
      index: res.length - 1,
      price: getRandomPrice() * dataMultiplier,
    });
    return controlPoints;
  }

  function getDiffDays(dateFrom, dateTo) {
    const df = convertBusinessDayToUTCTimestamp(dateFrom);
    const dt = convertBusinessDayToUTCTimestamp(dateTo);
    const diffTime = Math.abs(dt.getTime() - df.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  function convertBusinessDayToUTCTimestamp(date) {
    return new Date(Date.UTC(date.year, date.month - 1, date.day, 0, 0, 0, 0));
  }

  function nextBusinessDay(time) {
    const d = convertBusinessDayToUTCTimestamp({
      year: time.year,
      month: time.month,
      day: time.day + 1,
    });
    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth() + 1,
      day: d.getUTCDate(),
    };
  }

  function getRandomPrice() {
    return 10 + Math.round(Math.random() * 10000) / 100;
  }

  window.db = db;
  window.Dexie = Dexie;
  window.data = data;

  console.log(db);

  // Add the new friend!
  const id = db.friends.add({
    name: "Kinni",
    age: 103,
  });

  console.log(id);

  // db.candlesticks
  //   .bulkPut(data)
  //   .then(function (lastKey) {
  //     console.log("Done putting 100,000 raindrops all over the place");
  //     console.log("Last raindrop's id was: " + lastKey); // Will be 100000.
  //   })
  //   .catch(Dexie.BulkError, function (e) {
  //     // Explicitely catching the bulkAdd() operation makes those successful
  //     // additions commit despite that there were errors.
  //     console.error(
  //       "Some raindrops did not succeed. However, " +
  //         100000 -
  //         e.failures.length +
  //         " raindrops was added successfully"
  //     );
  //   });
</script>

<Chart width={600} height={300}>
  <TimeScale
    ref={handleTimeScaleRef}
    on:visibleLogicalRangeChange={handleVisibleLogicalRangeChange}
  />
  <CandlestickSeries
    ref={handleSeriesRef}
    {data}
    reactive={true}
    upColor="#089981"
    downColor="#F23645"
    drawWick={true}
    borderColor="#378658"
    borderUpColor="#089981"
    borderDownColor="#F23645"
    wickColor="#B5B5B8"
    wickUpColor="#089981"
    wickDownColor="#F23645"
    barColorsOnPrevClose={false}
  />
</Chart>
